#!/bin/bash

BOLD="\e[1m"
YELLOW="\033[0;33m"
GREY="\033[38;5;244m"
PURPLE="\033[0;35m"
BLUE="\033[0;36m"
RED="\e[0;31m"
END="\033[0m"
GREEN="\e[0;32m"

SEGFAULT_LOG_FILE="minishell_segfaults.log"
FAILED_TESTS_LOG_FILE="minishell_failed_tests.log"

if [ -f "$SEGFAULT_LOG_FILE" ]; then
	rm "$SEGFAULT_LOG_FILE"
fi
if [ -f "$FAILED_TESTS_LOG_FILE" ]; then
	rm "$FAILED_TESTS_LOG_FILE"
fi

make -C ../

if [ $? -eq 0 ]; then
	echo ""
	echo ""
	echo ""
	printf "$GREEN"
    echo "Compilation réussie !"
else
	printf "$RED"
    echo "Erreur de compilation."
	exit 1
fi

cp ../minishell minishell

MINISHELL_PATH="./minishell"

readarray -t lst_common  < lst_common
readarray -t lst_wildcat < lst_wildcat
readarray -t lst_lapinou < lst_lapinou
readarray -t lst_bonus   < lst_bonus

all=("${lst_common[@]}" "${lst_wildcat[@]}" "${lst_lapinou[@]}" "${lst_bonus[@]}")

#
#
# echo -e "unset -HELLO" | LANGUAGE=en LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8 bash --posix 
#
# printf "%s\n" bonus_* > lst_bonus
# printf "%s\n" wildcat_* > lst_wildcat
# printf "%s\n" common_* > lst_common
# printf "%s\n" lapinou_* > lst_lapinou
#
# Run a specific test if the file name was specified

shopt -s nullglob
if [[ $1 ]]; then
    # Cas où tu passes "wildcat", "lapinou", etc.
    if [[ $1 == wildcat || $1 == wildcat_ ]]; then
        test_lists=(wildcat_*.tests)
    elif [[ $1 == lapinou || $1 == lapinou_ ]]; then
        test_lists=(lapinou_*.tests)
    elif [[ $1 == common || $1 == common_ ]]; then
        test_lists=(common_*.tests)
    elif [[ $1 == bonus || $1 == bonus_ ]]; then
        test_lists=(bonus_*.tests)
    elif [[ -f $1 ]]; then
        # Cas où c’est un fichier test individuel
        test_lists=($1)
    else
        echo "Aucun test trouvé pour: $1" >&2
        exit 1
    fi
else
    # Liste complète par défaut
    test_lists=(
        common_*.tests
        lapinou_*.tests
        bonus_*.tests
        wildcat_*.tests
    )
fi
shopt -u nullglob

if [ ${#test_lists[@]} -eq 0 ]; then
    echo "Aucun fichier de test trouvé correspondant aux critères."
    if [[ $1 ]]; then
        echo "Critère fourni: $1"
    fi
    exit 1
fi

touch ./test_files/invalid_permission 2>/dev/null
chmod 000 ./test_files/invalid_permission 2>/dev/null
mkdir ./outfiles
mkdir ./mini_outfiles
mkdir ./bash_outfiles

printf "$GREEN"
echo ""
echo "        🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥";
echo "        🌴 Lapinou 🐰🐯 WiLDCaT 🌴🌴MiniShELL 🌴"
echo "        🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥🔥";
echo ""

PROMPT=$(echo -e "\nexit\n" | "$MINISHELL_PATH" | head -n 1 | sed "s/\x1B\[[0-9;]\{1,\}[A-Za-z]//g" )
# Helper commands:
REMOVE_COLORS="sed s/\x1B\[[0-9;]\{1,\}[A-Za-z]//g"
REMOVE_EXIT="grep -v ^exit$"

declare -a segfault_commands
declare -a failed_commands_for_rerun
ok=0
i=0
for testfile in ${test_lists[@]}; do

    if [[ ! -f "$testfile" ]]; then
        printf "$RED"
        echo "ATTENTION: Fichier de test '$testfile' non trouvé. Passage au suivant."
        printf "$END"
        continue
    fi
	if [[ ! -r "$testfile" ]]; then
		printf "$RED"
		echo "ATTENTION: Fichier de test '$testfile' non lisible. Passage au suivant."
		printf "$END"
		continue
	fi
	if [[ ! -s "$testfile" ]]; then
		printf "$RED"
		echo "ATTENTION: Fichier de test '$testfile' vide. Passage au suivant."
		printf "$END"
		continue
	fi

	printf "$RED"
	echo "———————————— $testfile"

	while IFS= read -r teste || [[ -n $teste ]]; do
		((i++))

		rm -rf ./outfiles/*
		rm -rf ./mini_outfiles/*

		MINI_OUTPUT=$(printf "$teste" | LANGUAGE=en LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8 $MINISHELL_PATH 2> /dev/null)
		MINI_EXIT_CODE=$?
		#MINI_EXIT_CODE=$(echo $MINI_EXIT_CODE_temp)
		MINI_OUTFILES=$(cp ./outfiles/* ./mini_outfiles &>/dev/null)
		#MINI_ERROR_MSG=$(printf "$teste" | LANGUAGE=en LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8 "$MINISHELL_PATH" 2>&1 > /dev/null | sed 's/.*: *//' )
		MINI_ERROR_MSG=$(trap "" PIPE && echo "$teste" |  LANGUAGE=en LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8 "$MINISHELL_PATH" 2>&1 > /dev/null |  sed 's/.*: *//' )

		rm -rf ./outfiles/*
		rm -rf ./bash_outfiles/*

		BASH_OUTPUT=$(printf "$teste" | LANGUAGE=en LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8 bash --posix --noprofile --norc 2> /dev/null)
		BASH_EXIT_CODE=$?
		#BASH_EXIT_CODE=$(echo $?)
		BASH_OUTFILES=$(cp ./outfiles/* ./bash_outfiles &>/dev/null)
		#BASH_ERROR_MSG=$(printf "$teste" | LANGUAGE=en LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8 bash --posix --noprofile --norc 2>&1 > /dev/null | sed
		BASH_ERROR_MSG=$(trap "" PIPE && echo "$teste" | LANGUAGE=en LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8 bash --posix --noprofile --norc 2>&1 > /dev/null | sed 's/.*: *//')

		OUTFILES_DIFF=$(diff --brief ./mini_outfiles ./bash_outfiles)

        if [[ "$MINI_EXIT_CODE" -eq 139 ]]; then
            segfault_commands+=("$teste")
        fi

		printf "$YELLOW"
		printf "Test %3s: " "$i"
		current_test_log_entry=""
        strict_fail=0

		if [[ "$MINI_OUTPUT" == "$BASH_OUTPUT" && "$MINI_EXIT_CODE" == "$BASH_EXIT_CODE" && -z "$OUTFILES_DIFF" ]]; then
			if [ "$MINI_ERROR_MSG" != "$BASH_ERROR_MSG" ]; then
				printf ✅
				printf "⚠️ "
				((ok++))
				current_test_log_entry+="WARN (STDERR Mismatch on PASS): $teste\n"
                current_test_log_entry+="  Minishell STDERR: ($MINI_ERROR_MSG)\n"
                current_test_log_entry+="  Bash POSIX STDERR: ($BASH_ERROR_MSG)\n"
			else
				printf ✅
				((ok++))
			fi
		else
			printf ❌
			strict_fail=1
            failed_commands_for_rerun+=("$teste")
            current_test_log_entry+="FAIL: $teste\n"
		fi

		printf "%b" "$GREY $teste \n$END"

        if [ "$strict_fail" -eq 1 ]; then
            if [ "$OUTFILES_DIFF" ]; then
                echo "$OUTFILES_DIFF"
                current_test_log_entry+="  Outfiles Diff: $OUTFILES_DIFF\n"
                echo "  minishell outfiles:"
                cat ./mini_outfiles/* 2>/dev/null || echo "    (no mini outfiles)"
                current_test_log_entry+="  Minishell outfiles content:\n$(cat ./mini_outfiles/* 2>/dev/null || echo '    (no mini outfiles)')\n"
                echo "  bash posix outfiles:"
                cat ./bash_outfiles/* 2>/dev/null || echo "    (no bash outfiles)"
                current_test_log_entry+="  Bash POSIX outfiles content:\n$(cat ./bash_outfiles/* 2>/dev/null || echo '    (no bash outfiles)')\n"
            fi
            if [ "$MINI_OUTPUT" != "$BASH_OUTPUT" ]; then
                echo "  minishell STDOUT = ($MINI_OUTPUT)"
                current_test_log_entry+="  Minishell STDOUT: ($MINI_OUTPUT)\n"
                echo "  bash posix STDOUT = ($BASH_OUTPUT)"
                current_test_log_entry+="  Bash POSIX STDOUT: ($BASH_OUTPUT)\n"
            fi
            if [ "$MINI_EXIT_CODE" != "$BASH_EXIT_CODE" ]; then
                echo "  minishell exit code = $MINI_EXIT_CODE"
                current_test_log_entry+="  Minishell Exit Code: $MINI_EXIT_CODE\n"
                echo "  bash posix exit code = $BASH_EXIT_CODE"
                current_test_log_entry+="  Bash POSIX Exit Code: $BASH_EXIT_CODE\n"
            fi
        fi

        # Always log error message differences if they exist, regardless of strict_fail, if not already part of PASS+WARN
        if [ "$MINI_ERROR_MSG" != "$BASH_ERROR_MSG" ]; then
            if ! ( [[ "$strict_fail" -eq 0 ]] && [[ "$current_test_log_entry" == *"WARN (STDERR Mismatch on PASS):"* ]] ) ; then
                 # if it's a strict fail, or if it's a pass but warning wasn't added yet (should not happen with current logic but safe check)
                echo "  minishell STDERR = ($MINI_ERROR_MSG)"
                current_test_log_entry+="  Minishell STDERR: ($MINI_ERROR_MSG)\n"
                echo "  bash posix STDERR = ($BASH_ERROR_MSG)"
                current_test_log_entry+="  Bash POSIX STDERR: ($BASH_ERROR_MSG)\n"
            fi
        fi
        
        if [[ -n "$current_test_log_entry" ]]; then
            printf "%b\n" "$current_test_log_entry" >> "$FAILED_TESTS_LOG_FILE"
        fi

        if [[ "$strict_fail" -eq 1 ]]; then
            echo "" # Extra newline for readability after a failed test's details
        fi
		# if [ "$OUTFILES_DIFF" ]; then
		# 	echo "$OUTFILES_DIFF"
		# 	echo minishell outfiles:
		# 	cat ./mini_outfiles/*
		# 	echo bash posix outfiles:
		# 	cat ./bash_outfiles/*
		# fi
		# if [ "$MINI_OUTPUT" != "$BASH_OUTPUT" ]; then
		# 	echo minishell out = \($MINI_OUTPUT\)
		# 	echo bash posix out = \($BASH_OUTPUT\)
		# fi
		# if [ "$MINI_EXIT_CODE" != "$BASH_EXIT_CODE" ]; then
		# 	echo minishell exit code = $MINI_EXIT_CODE
		# 	echo bash posix exit code = $BASH_EXIT_CODE
		# fi
		# if [ "$MINI_ERROR_MSG" != "$BASH_ERROR_MSG" ]; then
		# 	echo minishell error = \($MINI_ERROR_MSG\)
		# 	echo bash posix error = \($BASH_ERROR_MSG\)
		# fi
		# if [[ "$MINI_OUTPUT" != "$BASH_OUTPUT" || "$MINI_EXIT_CODE" != "$BASH_EXIT_CODE" || -n "$OUTFILES_DIFF"  ]]; then
		# 	echo ""
		# fi
	done < "$testfile"
done

#chmod 666 ./test_files/invalid_permission
rm -rf ./outfiles
rm -rf ./mini_outfiles
rm -rf ./bash_outfiles

if [ ${#segfault_commands[@]} -gt 0 ]; then
    printf "\n"
    printf "$RED$BOLD"
    echo "🚨 Commandes MiniShell avec Code d'Erreur 139 (Segmentation Fault) 🚨"
    printf "$END"
    for cmd in "${segfault_commands[@]}"; do
        printf "$GREY  - %s\n$END" "$cmd"
		echo "$cmd" >> "$SEGFAULT_LOG_FILE"
    done
    printf "\n"
	echo "Les commandes MiniShell qui ont provoqué un Segmentation Fault (code 139)"
	echo "sont enregistrées dans le fichier $SEGFAULT_LOG_FILE"
	printf "\n$RED$BOLD"
	echo "🚨 Vérifiez le fichier $SEGFAULT_LOG_FILE pour plus de détails. 🚨"
	printf "$END\n"
else
    printf "\n$GREEN$BOLD"
    echo "🎉 Aucune commande MiniShell n'a provoqué de Segmentation Fault (code 139) ! 🎉"
    printf "$END\n"
fi

# Rerun failed tests if any
if [ ${#failed_commands_for_rerun[@]} -gt 0 ]; then
    printf "\n$YELLOW"
    echo "Certains tests ont échoué (STDOUT, exit code, ou fichiers de sortie). Les détails sont enregistrés dans $FAILED_TESTS_LOG_FILE."
    printf "$END"
    
    # Default to No if timer runs out or input is empty/invalid
    rerun_choice="N"
    # -n 1: read only one char; -s: do not echo input; -r: raw input
    read -t 8 -n 1 -s -r -p "Voulez-vous relancer uniquement ces tests échoués ? (o/N) [8s]: " user_input 
    echo # Newline after input prompt
    if [[ "$user_input" == "o" || "$user_input" == "O" ]]; then
        rerun_choice="O"
    fi

    if [[ "$rerun_choice" == "O" ]]; then
        printf "$GREEN"
        echo "Relance des tests qui ont échoués..."
        printf "$END\n"
        
        mkdir -p ./outfiles ./mini_outfiles ./bash_outfiles # Ensure dirs exist for rerun

        rerun_ok=0
        rerun_total=${#failed_commands_for_rerun[@]}
        rerun_idx=0

        for teste_to_rerun in "${failed_commands_for_rerun[@]}"; do
            ((rerun_idx++))
            printf "$PURPLE"
            echo "--- Relance Test $rerun_idx/$rerun_total ---"
            printf "$END"

            rm -rf ./outfiles/*
            rm -rf ./mini_outfiles/*

            MINI_OUTPUT_RERUN=$(printf "%s" "$teste_to_rerun" | LANGUAGE=en LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8 "$MINISHELL_PATH" 2>/dev/null)
            MINI_EXIT_CODE_RERUN=$?
            cp ./outfiles/* ./mini_outfiles &>/dev/null
            MINI_ERROR_MSG_RERUN=$(trap "" PIPE && printf "%s" "$teste_to_rerun" | LANGUAGE=en LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8 "$MINISHELL_PATH" 2>&1 >/dev/null | sed 's/minishell: //; s/bash: //; s/.*: line [0-9]*: //')

            rm -rf ./outfiles/*
            rm -rf ./bash_outfiles/*

            BASH_OUTPUT_RERUN=$(printf "%s" "$teste_to_rerun" | LANGUAGE=en LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8 bash --posix --noprofile --norc 2>/dev/null)
            BASH_EXIT_CODE_RERUN=$?
            cp ./outfiles/* ./bash_outfiles &>/dev/null
            BASH_ERROR_MSG_RERUN=$(trap "" PIPE && printf "%s" "$teste_to_rerun" | LANGUAGE=en LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8 bash --posix --noprofile --norc 2>&1 >/dev/null | sed 's/minishell: //; s/bash: //; s/.*: line [0-9]*: //')
            
            OUTFILES_DIFF_RERUN=$(diff --brief ./mini_outfiles ./bash_outfiles 2>/dev/null)

            printf "$YELLOW"
            printf "Rerun Test: " 
            if [[ "$MINI_OUTPUT_RERUN" == "$BASH_OUTPUT_RERUN" && "$MINI_EXIT_CODE_RERUN" == "$BASH_EXIT_CODE_RERUN" && -z "$OUTFILES_DIFF_RERUN" ]]; then
                if [ "$MINI_ERROR_MSG_RERUN" != "$BASH_ERROR_MSG_RERUN" ]; then
                    printf ✅
                    printf "⚠️ "
                    ((rerun_ok++))
                else
                    printf ✅
                    ((rerun_ok++))
                fi
            else
                printf ❌
            fi
            printf "%b" "$GREY $teste_to_rerun \n$END"
            
            if [[ "$MINI_OUTPUT_RERUN" != "$BASH_OUTPUT_RERUN" || "$MINI_EXIT_CODE_RERUN" != "$BASH_EXIT_CODE_RERUN" || -n "$OUTFILES_DIFF_RERUN" || "$MINI_ERROR_MSG_RERUN" != "$BASH_ERROR_MSG_RERUN" ]]; then
                 if [ "$OUTFILES_DIFF_RERUN" ]; then
                    echo "  RERUN Outfiles Diff: $OUTFILES_DIFF_RERUN"
                    # Optionally cat contents for rerun
                fi
                if [ "$MINI_OUTPUT_RERUN" != "$BASH_OUTPUT_RERUN" ]; then
                    echo "  RERUN Minishell STDOUT: ($MINI_OUTPUT_RERUN)"
                    echo "  RERUN Bash POSIX STDOUT: ($BASH_OUTPUT_RERUN)"
                fi
                if [ "$MINI_EXIT_CODE_RERUN" != "$BASH_EXIT_CODE_RERUN" ]; then
                    echo "  RERUN Minishell Exit Code: $MINI_EXIT_CODE_RERUN"
                    echo "  RERUN Bash POSIX Exit Code: $BASH_EXIT_CODE_RERUN"
                fi
                 if [ "$MINI_ERROR_MSG_RERUN" != "$BASH_ERROR_MSG_RERUN" ]; then
                    echo "  RERUN Minishell STDERR: ($MINI_ERROR_MSG_RERUN)"
                    echo "  RERUN Bash POSIX STDERR: ($BASH_ERROR_MSG_RERUN)"
                fi
                echo ""
            fi
        done
        printf "$GREEN"
        echo "Fin de la relance. Résultats de la relance: $rerun_ok/$rerun_total tests OK."
        printf "$END\n"
        rm -rf ./outfiles ./mini_outfiles ./bash_outfiles
    else
        echo "Skipping rerun of failed tests."
    fi
    printf "\n"
fi


rm -f ./minishell
if [ -f "./test_files/invalid_permission" ]; then
	rm -f "./test_files/invalid_permission" 2>/dev/null
fi
rm -rf ./outfiles
rm -rf ./mini_outfiles
rm -rf ./bash_outfiles
rm -rf hola2
rm -rf minishell
rm -rf outfile01
rm -rf pwd

printf $PURPLE
printf $BOLD
if [ "$ok" -eq "$i" ]; then
	printf ">>$PURPLE RÉSULTATS : $ok/$i $END\n"
else
	printf ">>$RED RÉSULTATS : $ok/$i $END\n"
    echo -e "$YELLOW Vous êtes perdu dans la jungle de la programmation ! $END"
fi
printf $END

if [[ "$ok" == "$i" ]]; then
	echo ""
	echo "        🎊 🎊 🎊"
	echo "        🧃 😎 🃏"
	echo "        🎉 🎉 🎉"
	echo ""
	exit 0
else
	echo "  🌴🌴🌴🌴🌴🌴🌴🌴🌴🌴🌴🌴🌴"
	echo "    🌴🌴🐰🐰 🐯 🐰🌴🌴"
	echo "  🌴🌴🌴🐯🐯 🐰 🐯🐰🌴🌴🌴"
	echo "      🌴🐰🐰 🐯 🐰🌴🌴🌴"
	echo "    🌴🌴🐰🐯 😭 🐰🐰🌴🌴🌴🌴"
	echo "  🌴🌴🌴🐯🐯 🐰 🐯🌴🌴🌴🌴"
	echo "   🌴🌴🌴🐯🌴🐯 🌴🐯🐯🌴🌴"
	echo "  🌴🌴🌴🌴🌴🌴🌴🌴🌴🌴🌴🌴🌴"
	echo "Des tests ont échoué ! veuillez vérifier les fichiers de test."
	echo "Les détails sont enregistrés dans \$FAILED_TESTS_LOG_FILE"
	echo "et les erreurs de segmentation dans \$SEGFAULT_LOG_FILE"
	echo ""
	exit 1
fi
